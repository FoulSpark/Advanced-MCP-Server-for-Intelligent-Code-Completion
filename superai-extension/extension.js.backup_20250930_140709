const vscode = require('vscode');
const axios = require('axios');
const path = require('path');

// Configuration
const SERVER_URL = 'http://127.0.0.1:5000';
const COMPLETION_PROVIDER_ID = 'superai-completion';

// Global state
let diagnosticCollection;
let completionProvider;
let hoverProvider;
let statusBarItem;
let autoCompleteEnabled = true;

class SuperAICompletionProvider {
    async provideCompletionItems(document, position, token, context) {
        if (!autoCompleteEnabled) return [];
        
        try {
            const currentFile = document.uri.fsPath;
            const workspaceFolder = vscode.workspace.workspaceFolders ? 
                vscode.workspace.workspaceFolders[0].uri.fsPath : '';
            
            // Get context around cursor
            const lineText = document.lineAt(position.line).text;
            const cursorContext = lineText.substring(0, position.character);
            
            // Skip if context is too short or just whitespace
            if (!cursorContext.trim() || cursorContext.trim().length < 2) {
                return [];
            }
            
            const response = await axios.post(`${SERVER_URL}/auto_complete`, {
                current_file: currentFile,
                workspace_folder: workspaceFolder,
                cursor_context: cursorContext,
                cursor_position: document.offsetAt(position)
            }, { timeout: 5000 });
            
            if (response.data.error) {
                console.error('SuperAI Completion Error:', response.data.error);
                return [];
            }
            
            const completion = response.data.completion;
            if (!completion || !completion.trim()) {
                return [];
            }
            
            // Create completion item
            const item = new vscode.CompletionItem(
                completion.split('\n')[0], // First line as label
                vscode.CompletionItemKind.Snippet
            );
            
            item.insertText = new vscode.SnippetString(completion);
            item.detail = 'SuperAI Suggestion';
            item.documentation = new vscode.MarkdownString(
                `**AI-Generated Code**\n\n\`\`\`${document.languageId}\n${completion}\n\`\`\``
            );
            
            // Add context info if available
            if (response.data.context) {
                const ctx = response.data.context;
                item.documentation.appendMarkdown(
                    `\n\n**Context:** ${ctx.language} | ` +
                    `Functions: ${ctx.functions.length} | ` +
                    `Errors: ${ctx.errors.length}`
                );
            }
            
            return [item];
            
        } catch (error) {
            console.error('SuperAI Completion Provider Error:', error.message);
            return [];
        }
    }
}

class SuperAIHoverProvider {
    async provideHover(document, position, token) {
        try {
            const currentFile = document.uri.fsPath;
            
            const response = await axios.post(`${SERVER_URL}/analyze_file`, {
                file_path: currentFile
            }, { timeout: 3000 });
            
            if (response.data.error) return null;
            
            const analysis = response.data.analysis;
            if (!analysis) return null;
            
            const contents = new vscode.MarkdownString();
            contents.appendMarkdown(`**File Analysis**\n\n`);
            contents.appendMarkdown(`**Language:** ${response.data.language}\n`);
            contents.appendMarkdown(`**Lines:** ${response.data.line_count}\n`);
            
            if (analysis.functions && analysis.functions.length > 0) {
                contents.appendMarkdown(`**Functions:** ${analysis.functions.join(', ')}\n`);
            }
            
            if (analysis.classes && analysis.classes.length > 0) {
                contents.appendMarkdown(`**Classes:** ${analysis.classes.join(', ')}\n`);
            }
            
            if (analysis.errors && analysis.errors.length > 0) {
                contents.appendMarkdown(`**‚ö†Ô∏è Errors:** ${analysis.errors.length}\n`);
            }
            
            return new vscode.Hover(contents);
            
        } catch (error) {
            return null;
        }
    }
}

async function analyzeAndShowDiagnostics(document) {
    try {
        const currentFile = document.uri.fsPath;
        if (!currentFile || document.isUntitled) return;
        
        const response = await axios.post(`${SERVER_URL}/analyze_file`, {
            file_path: currentFile
        }, { timeout: 5000 });
        
        if (response.data.error) return;
        
        const analysis = response.data.analysis;
        if (!analysis || !analysis.errors) return;
        
        // Convert errors to VS Code diagnostics
        const diagnostics = analysis.errors.map(error => {
            const line = Math.max(0, (error.line || 1) - 1);
            const column = Math.max(0, error.column || 0);
            
            const range = new vscode.Range(
                new vscode.Position(line, column),
                new vscode.Position(line, column + 10)
            );
            
            const diagnostic = new vscode.Diagnostic(
                range,
                error.message || 'Unknown error',
                error.type === 'SyntaxError' ? 
                    vscode.DiagnosticSeverity.Error : 
                    vscode.DiagnosticSeverity.Warning
            );
            
            diagnostic.source = 'SuperAI';
            return diagnostic;
        });
        
        diagnosticCollection.set(document.uri, diagnostics);
        
    } catch (error) {
        console.error('Error analyzing file:', error.message);
    }
}

async function autoFixCode() {
    const editor = vscode.window.activeTextEditor;
    if (!editor) {
        vscode.window.showErrorMessage('No active file open.');
        return;
    }
    
    try {
        const document = editor.document;
        const currentFile = document.uri.fsPath;
        
        // Save the file first to ensure we're working with the latest version
        await document.save();
        
        vscode.window.showInformationMessage('üîß Auto-fixing and completing entire file...');
        
        // Use the new auto_fix_and_complete endpoint that modifies the file directly
        const response = await axios.post(`${SERVER_URL}/auto_fix_and_complete`, {
            file_path: currentFile
        }, { timeout: 15000 });
        
        if (response.data.error) {
            vscode.window.showErrorMessage('Auto-fix error: ' + response.data.error);
            return;
        }
        
        const result = response.data;
        if (result.success && result.total_modifications > 0) {
            // Reload the file to show the changes
            const uri = vscode.Uri.file(currentFile);
            await vscode.commands.executeCommand('workbench.action.files.revert', uri);
            
            let message = '‚úÖ File automatically updated!\n';
            
            const errorFixes = result.error_fixes;
            if (errorFixes && errorFixes.changes_made) {
                message += `üîß Fixed ${errorFixes.errors_resolved || 0} errors\n`;
            }
            
            const completions = result.completions_applied;
            if (completions && completions.modifications_made > 0) {
                message += `üöÄ Applied ${completions.modifications_made} code completions\n`;
            }
            
            message += `Total modifications: ${result.total_modifications}`;
            
            vscode.window.showInformationMessage(message);
        } else {
            vscode.window.showInformationMessage('‚úÖ No fixes or completions needed.');
        }
        
    } catch (error) {
        vscode.window.showErrorMessage('Auto-fix error: ' + error.message);
    }
}

async function showWorkspaceInfo() {
    try {
        const response = await axios.get(`${SERVER_URL}/workspace_info`);
        
        if (response.data.error) {
            vscode.window.showErrorMessage('Workspace info error: ' + response.data.error);
            return;
        }
        
        const info = response.data;
        const message = `Active Workspace: ${info.active_workspace || 'None'}\n` +
                       `Total Workspaces: ${info.workspace_count}`;
        
        vscode.window.showInformationMessage(message);
        
    } catch (error) {
        vscode.window.showErrorMessage('Workspace info error: ' + error.message);
    }
}

function updateStatusBar() {
    if (!statusBarItem) {
        statusBarItem = vscode.window.createStatusBarItem(
            vscode.StatusBarAlignment.Right, 
            100
        );
    }
    
    statusBarItem.text = autoCompleteEnabled ? 
        '$(check) SuperAI' : 
        '$(x) SuperAI';
    statusBarItem.tooltip = autoCompleteEnabled ? 
        'SuperAI Auto-completion enabled' : 
        'SuperAI Auto-completion disabled';
    statusBarItem.command = 'superai.toggleAutoComplete';
    statusBarItem.show();
}

function getTwoStageResultsHtml(result, todoCount, fixmeCount, passCount) {
    const stage1Code = result.stage1_fixed_code || '';
    const finalCode = result.final_completed_code || '';
    const stage1Analysis = result.stage1_analysis || {};
    const stage2Analysis = result.stage2_analysis || {};
    
    return `
    <!DOCTYPE html>
    <html>
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Two-Stage Gemini Results</title>
        <style>
            body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; margin: 20px; }
            .section { margin-bottom: 30px; padding: 15px; border: 1px solid #ddd; border-radius: 8px; }
            .success { background-color: #d4edda; border-color: #c3e6cb; }
            .warning { background-color: #fff3cd; border-color: #ffeaa7; }
            .error { background-color: #f8d7da; border-color: #f5c6cb; }
            .code-block { background-color: #f8f9fa; border: 1px solid #e9ecef; border-radius: 4px; padding: 15px; margin: 10px 0; overflow-x: auto; }
            pre { margin: 0; white-space: pre-wrap; font-family: 'Courier New', monospace; font-size: 12px; }
            h2 { margin-top: 0; color: #333; }
            h3 { color: #666; }
            .stats { display: flex; gap: 20px; margin: 15px 0; }
            .stat { padding: 10px; border-radius: 4px; text-align: center; min-width: 80px; }
            .stat-good { background-color: #d4edda; }
            .stat-bad { background-color: #f8d7da; }
            .stat-neutral { background-color: #e2e3e5; }
        </style>
    </head>
    <body>
        <h1>üîÑ Two-Stage Gemini Results</h1>
        
        <div class="section ${result.success ? 'success' : 'error'}">
            <h2>üìä Process Summary</h2>
            <p><strong>Status:</strong> ${result.success ? '‚úÖ Success' : '‚ùå Failed'}</p>
            <div class="stats">
                <div class="stat ${todoCount === 0 ? 'stat-good' : 'stat-bad'}">
                    <strong>${todoCount}</strong><br>TODOs Remaining
                </div>
                <div class="stat ${fixmeCount === 0 ? 'stat-good' : 'stat-bad'}">
                    <strong>${fixmeCount}</strong><br>FIXMEs Remaining
                </div>
                <div class="stat ${passCount === 0 ? 'stat-good' : 'stat-bad'}">
                    <strong>${passCount}</strong><br>Pass Statements
                </div>
            </div>
        </div>
        
        <div class="section">
            <h2>üîß Stage 1: Syntax Fixes</h2>
            <h3>Fixed Code:</h3>
            <div class="code-block">
                <pre><code>${stage1Code}</code></pre>
            </div>
            <h3>Analysis:</h3>
            <p>${JSON.stringify(stage1Analysis, null, 2)}</p>
        </div>
        
        <div class="section">
            <h2>üöÄ Stage 2: Final Implementation</h2>
            <h3>Complete Code:</h3>
            <div class="code-block">
                <pre><code>${finalCode}</code></pre>
            </div>
            <h3>Analysis:</h3>
            <p>${JSON.stringify(stage2Analysis, null, 2)}</p>
        </div>
        
        <div class="section ${todoCount === 0 && fixmeCount === 0 ? 'success' : 'warning'}">
            <h2>‚úÖ Validation Results</h2>
            <ul>
                <li>TODO Comments: ${todoCount === 0 ? '‚úÖ None remaining' : `‚ùå ${todoCount} still present`}</li>
                <li>FIXME Comments: ${fixmeCount === 0 ? '‚úÖ None remaining' : `‚ùå ${fixmeCount} still present`}</li>
                <li>Pass Statements: ${passCount === 0 ? '‚úÖ None remaining' : `‚ö†Ô∏è ${passCount} still present`}</li>
                <li>Process Status: ${result.success ? '‚úÖ Completed successfully' : '‚ùå Failed'}</li>
            </ul>
        </div>
    </body>
    </html>`;
}

function generateThreeStageResultsHTML(result) {
    const stage0Understanding = result.stage0_understanding || {};
    const stage1Code = result.stage1_fixed_code || '';
    const finalCode = result.final_completed_code || '';
    const stage0Analysis = result.stage0_analysis || {};
    const stage1Analysis = result.stage1_analysis || {};
    const stage2Analysis = result.stage2_analysis || {};
    
    // Count remaining issues
    const todoCount = (finalCode.match(/TODO|FIXME/gi) || []).length;
    const passCount = (finalCode.match(/^\s*pass\s*$/gm) || []).length;
    
    return `
    <!DOCTYPE html>
    <html>
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Three-Stage Gemini Results</title>
        <style>
            body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; margin: 20px; }
            .section { margin-bottom: 30px; padding: 15px; border: 1px solid #ddd; border-radius: 8px; }
            .success { background-color: #d4edda; border-color: #c3e6cb; }
            .warning { background-color: #fff3cd; border-color: #ffeaa7; }
            .error { background-color: #f8d7da; border-color: #f5c6cb; }
            .info { background-color: #d1ecf1; border-color: #bee5eb; }
            .code-block { background-color: #f8f9fa; border: 1px solid #e9ecef; border-radius: 4px; padding: 15px; margin: 10px 0; overflow-x: auto; }
            pre { margin: 0; white-space: pre-wrap; font-family: 'Courier New', monospace; font-size: 12px; }
            h2 { margin-top: 0; color: #333; }
            h3 { color: #666; }
            .stats { display: flex; gap: 20px; margin: 15px 0; }
            .stat { padding: 10px; border-radius: 4px; text-align: center; min-width: 80px; }
            .stat-good { background-color: #d4edda; }
            .stat-bad { background-color: #f8d7da; }
            .stat-neutral { background-color: #e2e3e5; }
            .understanding-item { margin: 10px 0; padding: 8px; background-color: #f8f9fa; border-radius: 4px; }
        </style>
    </head>
    <body>
        <h1>üß† Three-Stage Gemini Results</h1>
        
        <div class="section ${result.success ? 'success' : 'error'}">
            <h2>üìä Process Summary</h2>
            <p><strong>Status:</strong> ${result.success ? '‚úÖ Success' : '‚ùå Failed'}</p>
            <div class="stats">
                <div class="stat ${todoCount === 0 ? 'stat-good' : 'stat-bad'}">
                    <strong>${todoCount}</strong><br>TODOs Remaining
                </div>
                <div class="stat ${passCount === 0 ? 'stat-good' : 'stat-bad'}">
                    <strong>${passCount}</strong><br>Pass Statements
                </div>
                <div class="stat stat-good">
                    <strong>3</strong><br>Stages Completed
                </div>
            </div>
        </div>
        
        <div class="section info">
            <h2>üß† Stage 0: Code Understanding</h2>
            <h3>Understanding Analysis:</h3>
            <div class="understanding-item">
                <strong>Main Purpose:</strong> ${stage0Understanding.main_purpose || 'Not specified'}
            </div>
            <div class="understanding-item">
                <strong>Core Algorithm:</strong> ${stage0Understanding.core_algorithm || 'Not specified'}
            </div>
            <div class="understanding-item">
                <strong>Key Functions:</strong> ${Array.isArray(stage0Understanding.key_functions) ? stage0Understanding.key_functions.join(', ') : 'None identified'}
            </div>
            <div class="understanding-item">
                <strong>Data Flow:</strong> ${stage0Understanding.data_flow || 'Not specified'}
            </div>
            <div class="understanding-item">
                <strong>Expected Behavior:</strong> ${stage0Understanding.expected_behavior || 'Not specified'}
            </div>
            <div class="understanding-item">
                <strong>Missing Components:</strong> ${Array.isArray(stage0Understanding.missing_components) ? stage0Understanding.missing_components.join(', ') : 'None identified'}
            </div>
        </div>
        
        <div class="section">
            <h2>üîß Stage 1: Syntax Fixes (with Understanding)</h2>
            <h3>Fixed Code:</h3>
            <div class="code-block">
                <pre><code>${stage1Code}</code></pre>
            </div>
            <h3>Analysis:</h3>
            <p>${JSON.stringify(stage1Analysis, null, 2)}</p>
        </div>
        
        <div class="section">
            <h2>üöÄ Stage 2: Final Implementation (with Understanding)</h2>
            <h3>Complete Code:</h3>
            <div class="code-block">
                <pre><code>${finalCode}</code></pre>
            </div>
            <h3>Analysis:</h3>
            <p>${JSON.stringify(stage2Analysis, null, 2)}</p>
        </div>
        
        <div class="section ${todoCount === 0 ? 'success' : 'warning'}">
            <h2>‚úÖ Validation Results</h2>
            <ul>
                <li>Code Understanding: ${stage0Understanding.main_purpose ? '‚úÖ Successfully analyzed' : '‚ùå Failed to understand'}</li>
                <li>TODO Comments: ${todoCount === 0 ? '‚úÖ None remaining' : `‚ùå ${todoCount} still present`}</li>
                <li>Pass Statements: ${passCount === 0 ? '‚úÖ None remaining' : `‚ö†Ô∏è ${passCount} still present`}</li>
                <li>Process Status: ${result.success ? '‚úÖ Completed successfully' : '‚ùå Failed'}</li>
            </ul>
        </div>
    </body>
    </html>`;
}

function generateAPIKeyStatusHTML(status) {
    const apiStatus = status.api_key_manager_status || {};
    const keyUsage = apiStatus.key_usage || {};
    const keyErrors = apiStatus.key_errors || {};
    const keyConsecutiveErrors = apiStatus.key_consecutive_errors || {};
    const rotationInfo = status.rotation_info || {};
    
    const totalKeys = apiStatus.total_keys || 0;
    const totalRequests = status.total_requests || 0;
    const totalErrors = status.total_errors || 0;
    const healthyKeys = status.healthy_keys || 0;
    const currentActiveKey = rotationInfo.current_active_key || 'None';
    const rotationThreshold = rotationInfo.rotation_threshold || 3;
    
    let keyStatusHTML = '';
    Object.keys(keyUsage).forEach((key, index) => {
        const usage = keyUsage[key] || 0;
        const errors = keyErrors[key] || 0;
        const consecutiveErrors = keyConsecutiveErrors[key] || 0;
        const isActive = key.substring(0, 10) + '...' === currentActiveKey;
        const isHealthy = consecutiveErrors < rotationThreshold;
        const keyDisplay = key.substring(0, 10) + '...';
        
        keyStatusHTML += `
            <div class="key-status ${isActive ? 'key-active' : (isHealthy ? 'key-healthy' : 'key-exhausted')}">
                <strong>${isActive ? 'üéØ ACTIVE' : 'Key'} ${index + 1}:</strong> ${keyDisplay}<br>
                <span>Requests: ${usage}</span><br>
                <span>Total Errors: ${errors}</span><br>
                <span>Consecutive Errors: ${consecutiveErrors}/${rotationThreshold}</span><br>
                <span>Status: ${isActive ? 'üéØ Currently Active' : (isHealthy ? '‚úÖ Healthy' : 'üî• Exhausted')}</span>
            </div>
        `;
    });
    
    return `
    <!DOCTYPE html>
    <html>
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Gemini API Key Status</title>
        <style>
            body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; margin: 20px; }
            .section { margin-bottom: 30px; padding: 15px; border: 1px solid #ddd; border-radius: 8px; }
            .success { background-color: #d4edda; border-color: #c3e6cb; }
            .warning { background-color: #fff3cd; border-color: #ffeaa7; }
            .error { background-color: #f8d7da; border-color: #f5c6cb; }
            .info { background-color: #d1ecf1; border-color: #bee5eb; }
            h2 { margin-top: 0; color: #333; }
            h3 { color: #666; }
            .stats { display: flex; gap: 20px; margin: 15px 0; flex-wrap: wrap; }
            .stat { padding: 15px; border-radius: 4px; text-align: center; min-width: 100px; }
            .stat-good { background-color: #d4edda; }
            .stat-bad { background-color: #f8d7da; }
            .stat-neutral { background-color: #e2e3e5; }
            .key-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin: 15px 0; }
            .key-status { padding: 10px; border-radius: 4px; border: 1px solid #ddd; }
            .key-active { background-color: #cce5ff; border-color: #0066cc; border-width: 2px; }
            .key-healthy { background-color: #d4edda; border-color: #c3e6cb; }
            .key-exhausted { background-color: #f8d7da; border-color: #f5c6cb; }
            .stage-config { margin: 10px 0; padding: 8px; background-color: #f8f9fa; border-radius: 4px; }
        </style>
    </head>
    <body>
        <h1>üîÑ Smart API Key Rotation Status</h1>
        
        <div class="section ${totalErrors === 0 ? 'success' : 'warning'}">
            <h2>üìä Rotation System Status</h2>
            <div class="stats">
                <div class="stat ${totalKeys > 0 ? 'stat-good' : 'stat-bad'}">
                    <strong>${totalKeys}</strong><br>Total Keys
                </div>
                <div class="stat ${healthyKeys === totalKeys ? 'stat-good' : 'stat-bad'}">
                    <strong>${healthyKeys}</strong><br>Healthy Keys
                </div>
                <div class="stat stat-neutral">
                    <strong>${totalRequests}</strong><br>Total Requests
                </div>
                <div class="stat ${totalErrors === 0 ? 'stat-good' : 'stat-bad'}">
                    <strong>${totalErrors}</strong><br>Total Errors
                </div>
            </div>
        </div>
        
        <div class="section info">
            <h2>üéØ Current Rotation Status</h2>
            <div class="stage-config">
                <strong>üéØ Active Key:</strong> ${currentActiveKey}
            </div>
            <div class="stage-config">
                <strong>üîÑ Rotation Threshold:</strong> ${rotationThreshold} consecutive errors
            </div>
            <div class="stage-config">
                <strong>‚ö° System Type:</strong> ${rotationInfo.system_type || 'Smart single-key rotation on exhaustion'}
            </div>
            <div class="stage-config">
                <strong>üõ°Ô∏è Auto-Rotation:</strong> ‚úÖ Enabled (seamless key switching)
            </div>
        </div>
        
        <div class="section">
            <h2>üîê Individual Key Status</h2>
            <div class="key-grid">
                ${keyStatusHTML || '<p>No API keys configured</p>'}
            </div>
        </div>
        
        <div class="section info">
            <h2>üí° Smart Rotation Configuration</h2>
            <ul>
                <li><strong>Rotation Pool:</strong> Set GEMINI_API_KEY_1, GEMINI_API_KEY_2, etc. for automatic rotation</li>
                <li><strong>Single Active Key:</strong> System uses one key at a time, rotating on exhaustion (${rotationThreshold} consecutive errors)</li>
                <li><strong>No Breakpoints:</strong> Seamless switching prevents service interruption</li>
                <li><strong>Auto-Recovery:</strong> Keys can recover and be used again when healthy</li>
                <li><strong>Smart Monitoring:</strong> Real-time tracking of consecutive errors per key</li>
                <li><strong>Backup Keys:</strong> Legacy stage-specific keys are included as backup options</li>
            </ul>
        </div>
    </body>
    </html>`;
}

function activate(context) {
    console.log('SuperAI Extension activating...');
    
    // Create diagnostic collection
    diagnosticCollection = vscode.languages.createDiagnosticCollection('superai');
    context.subscriptions.push(diagnosticCollection);
    
    // Register completion provider
    completionProvider = vscode.languages.registerCompletionItemProvider(
        { scheme: 'file' },
        new SuperAICompletionProvider(),
        '.', ' ', '(', '=', ':'
    );
    context.subscriptions.push(completionProvider);
    
    // Register hover provider
    hoverProvider = vscode.languages.registerHoverProvider(
        { scheme: 'file' },
        new SuperAIHoverProvider()
    );
    context.subscriptions.push(hoverProvider);
    
    // Manual completion command - now uses global completion
    const completeCodeCommand = vscode.commands.registerCommand('superai.completeCode', async () => {
        const editor = vscode.window.activeTextEditor;
        if (!editor) {
            vscode.window.showErrorMessage('No active file open.');
            return;
        }
        
        try {
            const document = editor.document;
            const currentFile = document.uri.fsPath;
            
            // Save the file first
            await document.save();
            
            vscode.window.showInformationMessage('üöÄ Applying global completions to entire file...');
            
            // Use the new apply_completions endpoint that modifies the file directly
            const response = await axios.post(`${SERVER_URL}/apply_completions`, {
                file_path: currentFile
            }, { timeout: 15000 });
            
            if (response.data.error) {
                vscode.window.showErrorMessage('Completion Error: ' + response.data.error);
                return;
            }
            
            const result = response.data;
            if (result.success && result.modifications_made > 0) {
                // Reload the file to show the changes
                const uri = vscode.Uri.file(currentFile);
                await vscode.commands.executeCommand('workbench.action.files.revert', uri);
                
                let message = `‚úÖ Applied ${result.modifications_made} completions to file!\n`;
                message += `Found ${result.total_completions_found} incomplete patterns.`;
                
                if (result.applied_completions && result.applied_completions.length > 0) {
                    message += '\n\nCompleted:';
                    result.applied_completions.slice(0, 3).forEach((comp, i) => {
                        message += `\n${i + 1}. Line ${comp.line}: ${comp.type}`;
                    });
                    if (result.applied_completions.length > 3) {
                        message += `\n... and ${result.applied_completions.length - 3} more`;
                    }
                }
                
                vscode.window.showInformationMessage(message);
            } else {
                vscode.window.showInformationMessage('‚úÖ No incomplete patterns found to complete.');
            }
            
        } catch (error) {
            vscode.window.showErrorMessage('Error applying completions: ' + error.message);
        }
    });
    
    // Auto-fix command
    const autoFixCommand = vscode.commands.registerCommand('superai.autoFix', autoFixCode);
    
    // Global complete command
    const globalCompleteCommand = vscode.commands.registerCommand('superai.globalComplete', async () => {
        const editor = vscode.window.activeTextEditor;
        if (!editor) {
            vscode.window.showErrorMessage('No active file open.');
            return;
        }
        
        try {
            const document = editor.document;
            const currentFile = document.uri.fsPath;
            
            await document.save();
            
            vscode.window.showInformationMessage('üéØ Applying only completions to file...');
            
            const response = await axios.post(`${SERVER_URL}/apply_completions`, {
                file_path: currentFile
            }, { timeout: 15000 });
            
            if (response.data.error) {
                vscode.window.showErrorMessage('Global completion error: ' + response.data.error);
                return;
            }
            
            const result = response.data;
            if (result.success && result.modifications_made > 0) {
                const uri = vscode.Uri.file(currentFile);
                await vscode.commands.executeCommand('workbench.action.files.revert', uri);
                
                vscode.window.showInformationMessage(
                    `‚úÖ Applied ${result.modifications_made} completions! Found ${result.total_completions_found} patterns.`
                );
            } else {
                vscode.window.showInformationMessage('‚úÖ No incomplete patterns found.');
            }
            
        } catch (error) {
            vscode.window.showErrorMessage('Global completion error: ' + error.message);
        }
    });
    
    // Write fixed code command
    const writeFixedCodeCommand = vscode.commands.registerCommand('superai.writeFixedCode', async () => {
        const editor = vscode.window.activeTextEditor;
        if (!editor) {
            vscode.window.showErrorMessage('No active file open.');
            return;
        }
        
        try {
            const document = editor.document;
            const currentFile = document.uri.fsPath;
            
            await document.save();
            
            vscode.window.showInformationMessage('üîß Writing fixed code to file...');
            
            const response = await axios.post(`${SERVER_URL}/write_fixed_code`, {
                file_path: currentFile
            }, { timeout: 10000 });
            
            if (response.data.error) {
                vscode.window.showErrorMessage('Write fixed code error: ' + response.data.error);
                return;
            }
            
            const result = response.data;
            if (result.success && result.changes_applied) {
                const uri = vscode.Uri.file(currentFile);
                await vscode.commands.executeCommand('workbench.action.files.revert', uri);
                
                vscode.window.showInformationMessage(
                    `‚úÖ Fixed ${result.errors_fixed} errors and wrote to file!`
                );
            } else {
                vscode.window.showInformationMessage('‚úÖ No errors found to fix.');
            }
            
        } catch (error) {
            vscode.window.showErrorMessage('Write fixed code error: ' + error.message);
        }
    });
    
    // Analyze file command
    const analyzeCommand = vscode.commands.registerCommand('superai.analyzeFile', async () => {
        const editor = vscode.window.activeTextEditor;
        if (!editor) {
            vscode.window.showErrorMessage('No active file open.');
            return;
        }
        
        await analyzeAndShowDiagnostics(editor.document);
        vscode.window.showInformationMessage('File analysis complete.');
    });
    
    // Workspace info command
    const workspaceInfoCommand = vscode.commands.registerCommand('superai.workspaceInfo', showWorkspaceInfo);
    
    // Toggle auto-complete command
    const toggleAutoCompleteCommand = vscode.commands.registerCommand('superai.toggleAutoComplete', () => {
        autoCompleteEnabled = !autoCompleteEnabled;
        updateStatusBar();
        vscode.window.showInformationMessage(
            `SuperAI Auto-completion ${autoCompleteEnabled ? 'enabled' : 'disabled'}`
        );
    });
            
            // Show progress message
            vscode.window.showInformationMessage('üîÑ Starting Three-Stage Gemini Analysis & Fix...');
            
            // Call the three-stage Gemini endpoint
            const response = await axios.post(`${SERVER_URL}/three_stage_gemini_fix`, {
                file_path: currentFile,
                code_content: codeContent,
                user_instruction: "Understand the code purpose, fix all syntax errors, and implement all TODO items with working code",
                apply_changes: false
            }, { timeout: 180000 }); // 3 minute timeout for AI processing
            
            if (response.data.error) {
                vscode.window.showErrorMessage('Three-Stage Gemini Error: ' + response.data.error);
                return;
            }
            
            const result = response.data;
            
            if (result.success) {
                // Ask user if they want to apply changes
                const applyChanges = await vscode.window.showQuickPick(
                    ['Apply Changes', 'View Results Only'],
                    { placeHolder: 'Three-stage analysis complete. What would you like to do?' }
                );
                
                if (applyChanges === 'Apply Changes') {
                    // Replace document content
                    const edit = new vscode.WorkspaceEdit();
                    const fullRange = new vscode.Range(
                        document.positionAt(0),
                        document.positionAt(document.getText().length)
                    );
                    edit.replace(document.uri, fullRange, result.final_completed_code);
                    await vscode.workspace.applyEdit(edit);
                    await document.save();
                    
                    vscode.window.showInformationMessage(
                        `üéâ Three-Stage Gemini Fix Applied!\n` +
                        `üß† Stage 0: Code understanding completed\n` +
                        `‚úÖ Stage 1: All syntax errors fixed\n` +
                        `‚úÖ Stage 2: All TODO items implemented\n` +
                        `‚úÖ Code is now complete and functional`
                    );
                }
                
                // Create results panel
                const panel = vscode.window.createWebviewPanel(
                    'threeStageResults',
                    'Three-Stage Gemini Results',
                    vscode.ViewColumn.Beside,
                    { enableScripts: true }
                );
                
                panel.webview.html = generateThreeStageResultsHTML(result);
                
            } else {
                vscode.window.showErrorMessage('Three-Stage Gemini failed: ' + (result.error || 'Unknown error'));
            }
            
        } catch (error) {
            vscode.window.showErrorMessage('Three-Stage Gemini error: ' + error.message);
        }
    });

    // API Key Status command
    const apiKeyStatusCommand = vscode.commands.registerCommand('superai.apiKeyStatus', async () => {
        try {
            const response = await axios.get(`${SERVER_URL}/api_key_status`, { timeout: 5000 });
            
            if (response.data.error) {
                vscode.window.showErrorMessage('API Key Status Error: ' + response.data.error);
                return;
            }
            
            const status = response.data;
            
            // Create status panel
            const panel = vscode.window.createWebviewPanel(
                'apiKeyStatus',
                'Gemini API Key Status',
                vscode.ViewColumn.Beside,
                { enableScripts: true }
            );
            
            panel.webview.html = generateAPIKeyStatusHTML(status);
            
        } catch (error) {
            vscode.window.showErrorMessage('API Key Status error: ' + error.message);
        }
    });

    // Two-Stage Gemini Fix & Complete command
    const twoStageGeminiFixCommand = vscode.commands.registerCommand('superai.twoStageGeminiFix', async () => {
        const editor = vscode.window.activeTextEditor;
        if (!editor) {
            vscode.window.showErrorMessage('No active file open.');
            return;
        }
        
        try {
            const document = editor.document;
            const currentFile = document.uri.fsPath;
            const codeContent = document.getText();
            
            // Show progress message
            vscode.window.showInformationMessage('üîÑ Starting Two-Stage Gemini Fix & Complete...');
            
            // Call the two-stage Gemini endpoint
            const response = await axios.post(`${SERVER_URL}/two_stage_gemini_fix`, {
                file_path: currentFile,
                code_content: codeContent,
                user_instruction: "Fix all syntax errors and implement all TODO items with working code",
                apply_changes: false // We'll handle the file update ourselves
            }, { timeout: 120000 }); // 2 minute timeout for AI processing
            
            if (response.data.error) {
                vscode.window.showErrorMessage('Two-Stage Gemini Error: ' + response.data.error);
                return;
            }
            
            const result = response.data;
            if (result.success) {
                // Show detailed results
                const stage1Code = result.stage1_fixed_code || '';
                const finalCode = result.final_completed_code || '';
                
                // Count improvements
                const todoCount = finalCode.split('TODO').length - 1;
                const fixmeCount = finalCode.split('FIXME').length - 1;
                const passCount = (finalCode.match(/\n\s*pass\s*$/gm) || []).length;
                
                // Create results panel
                const panel = vscode.window.createWebviewPanel(
                    'twoStageResults',
                    'Two-Stage Gemini Results',
                    vscode.ViewColumn.Beside,
                    { enableScripts: true }
                );
                
                panel.webview.html = getTwoStageResultsHtml(result, todoCount, fixmeCount, passCount);
                
                // Ask user if they want to apply the changes
                const choice = await vscode.window.showInformationMessage(
                    `‚úÖ Two-Stage Process Complete!\n` +
                    `üîß Stage 1: Fixed syntax errors\n` +
                    `üöÄ Stage 2: Implemented ${result.stage1_analysis?.todo_items?.length || 0} TODO items\n` +
                    `üìä Final: ${todoCount} TODOs remaining (should be 0)\n\n` +
                    `Apply changes to file?`,
                    'Apply Changes',
                    'View Only',
                    'Cancel'
                );
                
                if (choice === 'Apply Changes') {
                    // Replace the entire document content
                    const edit = new vscode.WorkspaceEdit();
                    const fullRange = new vscode.Range(
                        document.positionAt(0),
                        document.positionAt(document.getText().length)
                    );
                    edit.replace(document.uri, fullRange, finalCode);
                    
                    await vscode.workspace.applyEdit(edit);
                    await document.save();
                    
                    vscode.window.showInformationMessage(
                        `üéâ Two-Stage Gemini Fix Applied!\n` +
                        `‚úÖ All syntax errors fixed\n` +
                        `‚úÖ All TODO items implemented\n` +
                        `‚úÖ Code is now complete and functional`
                    );
                }
                
            } else {
                vscode.window.showErrorMessage('Two-Stage Gemini failed: ' + (result.error || 'Unknown error'));
            }
            
        } catch (error) {
            vscode.window.showErrorMessage('Two-Stage Gemini error: ' + error.message);
        }
    });

    // Enhanced Syntax Fix command
    const enhancedSyntaxFixCommand = vscode.commands.registerCommand('superai.enhancedSyntaxFix', async () => {
        const editor = vscode.window.activeTextEditor;
        if (!editor) {
            vscode.window.showErrorMessage('No active file open.');
            return;
        }
        
        try {
            const document = editor.document;
            const filePath = document.uri.fsPath;
            const codeContent = document.getText();
            
            vscode.window.showInformationMessage('üîß Starting Enhanced Syntax Fix (Auto-Creating Functions)...');
            
            const response = await axios.post(`${SERVER_URL}/enhanced_syntax_fix`, {
                file_path: filePath,
                code_content: codeContent,
                apply_changes: false
            }, { timeout: 30000 });
            
            const result = response.data;
            
            if (result.success) {
                // Show results in a new document
                const fixedCode = result.fixed_code;
                const fixesApplied = result.fixes_applied || [];
                
                // Create results HTML
                const resultsHtml = `
<!DOCTYPE html>
<html>
<head>
    <title>Enhanced Syntax Fix Results</title>
    <style>
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; margin: 20px; background: #1e1e1e; color: #d4d4d4; }
        .header { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 20px; border-radius: 8px; margin-bottom: 20px; }
        .section { background: #2d2d30; padding: 15px; margin: 10px 0; border-radius: 8px; border-left: 4px solid #007acc; }
        .fixes-list { background: #0e2f1e; border-left: 4px solid #4caf50; padding: 15px; margin: 10px 0; border-radius: 8px; }
        .fix-item { margin: 8px 0; padding: 8px; background: #1a4a2e; border-radius: 4px; }
        .code-block { background: #1e1e1e; border: 1px solid #3c3c3c; padding: 15px; border-radius: 8px; font-family: 'Consolas', monospace; white-space: pre-wrap; overflow-x: auto; }
        .success { color: #4caf50; }
        .info { color: #2196f3; }
        .warning { color: #ff9800; }
        .button { background: #007acc; color: white; padding: 10px 20px; border: none; border-radius: 4px; cursor: pointer; margin: 5px; }
        .button:hover { background: #005a9e; }
    </style>
</head>
<body>
    <div class="header">
        <h1>üîß Enhanced Syntax Fix Results</h1>
        <p>Comprehensive intelligent fixing with auto-function generation</p>
    </div>
    
    <div class="fixes-list">
        <h2 class="success">‚úÖ Fixes Applied:</h2>
        ${fixesApplied.map(fix => `<div class="fix-item">‚Ä¢ ${fix}</div>`).join('')}
    </div>
    
    <div class="section">
        <h2 class="info">üìã Fixed Code:</h2>
        <div class="code-block">${fixedCode.replace(/</g, '&lt;').replace(/>/g, '&gt;')}</div>
    </div>
    
    <div class="section">
        <h2 class="warning">‚ö†Ô∏è Next Steps:</h2>
        <p>1. Review the automatically created functions</p>
        <p>2. Apply changes to your file if satisfied</p>
        <p>3. Test the enhanced code functionality</p>
        <p>4. Use Three-Stage Gemini Fix for complete implementation</p>
    </div>
</body>
</html>`;
                
                // Show in webview
                const panel = vscode.window.createWebviewPanel(
                    'enhancedSyntaxFixResults',
                    'Enhanced Syntax Fix Results',
                    vscode.ViewColumn.Beside,
                    { enableScripts: true }
                );
                panel.webview.html = resultsHtml;
                
                // Ask if user wants to apply changes
                const applyChanges = await vscode.window.showInformationMessage(
                    `üéâ Enhanced Syntax Fix Complete!\n` +
                    `‚úÖ ${fixesApplied.length} fixes applied\n` +
                    `‚úÖ Missing functions auto-created\n` +
                    `‚úÖ Variable typos corrected\n` +
                    `‚úÖ Colon placement fixed\n\n` +
                    `Apply changes to file?`,
                    'Apply Changes', 'Review Only'
                );
                
                if (applyChanges === 'Apply Changes') {
                    // Apply the fixed code to the editor
                    const edit = new vscode.WorkspaceEdit();
                    const fullRange = new vscode.Range(
                        document.positionAt(0),
                        document.positionAt(codeContent.length)
                    );
                    edit.replace(document.uri, fullRange, fixedCode);
                    await vscode.workspace.applyEdit(edit);
                    await document.save();
                    
                    vscode.window.showInformationMessage(
                        `üéâ Enhanced Syntax Fix Applied!\n` +
                        `‚úÖ Missing functions created automatically\n` +
                        `‚úÖ All syntax errors fixed\n` +
                        `‚úÖ Variable typos corrected\n` +
                        `‚úÖ Code is now syntactically correct`
                    );
                }
                
            } else {
                vscode.window.showErrorMessage('Enhanced Syntax Fix failed: ' + (result.error || 'Unknown error'));
            }
            
        } catch (error) {
            vscode.window.showErrorMessage('Enhanced Syntax Fix error: ' + error.message);
        }
    });

    // Four-Stage Gemini Fix command
    const fourStageGeminiFixCommand = vscode.commands.registerCommand('superai.fourStageGeminiFix', async () => {
        const editor = vscode.window.activeTextEditor;
        if (!editor) {
            vscode.window.showErrorMessage('No active file open.');
            return;
        }
        
        try {
            const document = editor.document;
            const filePath = document.uri.fsPath;
            const codeContent = document.getText();
            
            vscode.window.showInformationMessage('üöÄ Starting Four-Stage Gemini Fix (Understand‚ÜíPlan‚ÜíImplement‚ÜíReplace)...');
            
            const response = await axios.post(`${SERVER_URL}/four_stage_gemini_fix`, {
                file_path: filePath,
                code_content: codeContent,
                apply_changes: false
            }, { timeout: 60000 });
            
            const result = response.data;
            
            if (result.success) {
                // Show results in a new document
                const finalCode = result.final_code;
                const stage0Result = result.stage0_result || {};
                const stage1Result = result.stage1_result || {};
                const stage2Result = result.stage2_result || {};
                const stage3Result = result.stage3_result || {};
                const summary = result.summary || {};
                
                // Create comprehensive results HTML
                const resultsHtml = `
<!DOCTYPE html>
<html>
<head>
    <title>Four-Stage Gemini Results</title>
    <style>
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; margin: 20px; background: #1e1e1e; color: #d4d4d4; }
        .header { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 20px; border-radius: 8px; margin-bottom: 20px; }
        .stage { background: #2d2d30; padding: 15px; margin: 10px 0; border-radius: 8px; border-left: 4px solid #007acc; }
        .stage-0 { border-left-color: #ff6b6b; }
        .stage-1 { border-left-color: #4ecdc4; }
        .stage-2 { border-left-color: #45b7d1; }
        .stage-3 { border-left-color: #96ceb4; }
        .summary { background: #0e2f1e; border-left: 4px solid #4caf50; padding: 15px; margin: 10px 0; border-radius: 8px; }
        .code-block { background: #1e1e1e; border: 1px solid #3c3c3c; padding: 15px; border-radius: 8px; font-family: 'Consolas', monospace; white-space: pre-wrap; overflow-x: auto; max-height: 300px; }
        .success { color: #4caf50; }
        .info { color: #2196f3; }
        .warning { color: #ff9800; }
        .stage-title { font-size: 18px; font-weight: bold; margin-bottom: 10px; }
        .metric { margin: 5px 0; padding: 5px; background: #333; border-radius: 4px; }
    </style>
</head>
<body>
    <div class="header">
        <h1>üöÄ Four-Stage Gemini Results</h1>
        <p>Understand ‚Üí Plan ‚Üí Implement ‚Üí Replace</p>
    </div>
    
    <div class="summary">
        <h2 class="success">üìä Summary:</h2>
        <div class="metric">‚úÖ Stage 0 Success: ${summary.stage0_success ? 'Yes' : 'No'}</div>
        <div class="metric">üìã Stage 1 Success: ${summary.stage1_success ? 'Yes' : 'No'}</div>
        <div class="metric">üõ†Ô∏è Stage 2 Success: ${summary.stage2_success ? 'Yes' : 'No'}</div>
        <div class="metric">üîÑ Stage 3 Success: ${summary.stage3_success ? 'Yes' : 'No'}</div>
        <div class="metric">üß† Understanding Fields: ${summary.understanding_fields || 0}</div>
        <div class="metric">üìã Plan Components: ${summary.plan_components || 0}</div>
        <div class="metric">üõ†Ô∏è Implementations Created: ${summary.implementations_created || 0}</div>
        <div class="metric">üîÑ Replacements Made: ${summary.replacements_made || 0}</div>
        <div class="metric">‚úÖ Final Code Valid: ${summary.final_code_valid ? 'Yes' : 'No'}</div>
        <div class="metric">üéØ TODOs Eliminated: ${summary.todos_eliminated ? 'Yes' : 'No'}</div>
    </div>
    
    <div class="stage stage-0">
        <div class="stage-title">üß† Stage 0: Code Understanding</div>
        <p><strong>Status:</strong> ${stage0Result.success ? '‚úÖ Success' : '‚ùå Failed'}</p>
        ${stage0Result.understanding ? `
        <p><strong>Main Purpose:</strong> ${stage0Result.understanding.main_purpose || 'Not identified'}</p>
        <p><strong>Core Algorithm:</strong> ${stage0Result.understanding.core_algorithm || 'Not identified'}</p>
        <p><strong>Key Functions:</strong> ${stage0Result.understanding.key_functions || 'Not identified'}</p>
        ` : ''}
    </div>
    
    <div class="stage stage-1">
        <div class="stage-title">üìã Stage 1: Comprehensive Planning</div>
        <p><strong>Status:</strong> ${stage1Result.success ? '‚úÖ Success' : '‚ùå Failed'}</p>
        ${stage1Result.plan ? `
        <p><strong>Syntax Fixes:</strong> ${stage1Result.plan.syntax_fixes || 'None planned'}</p>
        <p><strong>Variable Corrections:</strong> ${stage1Result.plan.variable_corrections || 'None planned'}</p>
        <p><strong>Missing Functions:</strong> ${stage1Result.plan.missing_functions || 'None planned'}</p>
        ` : ''}
    </div>
    
    <div class="stage stage-2">
        <div class="stage-title">üõ†Ô∏è Stage 2: Implementation</div>
        <p><strong>Status:</strong> ${stage2Result.success ? '‚úÖ Success' : '‚ùå Failed'}</p>
        ${stage2Result.implementations ? `
        <p><strong>Functions Created:</strong> ${stage2Result.implementations.missing_functions ? 'Yes' : 'None'}</p>
        <p><strong>Syntax Fixed:</strong> ${stage2Result.implementations.syntax_fixes ? 'Yes' : 'None'}</p>
        <p><strong>Variables Corrected:</strong> ${stage2Result.implementations.variable_corrections ? 'Yes' : 'None'}</p>
        ` : ''}
    </div>
    
    <div class="stage stage-3">
        <div class="stage-title">üîÑ Stage 3: Intelligent Replacement</div>
        <p><strong>Status:</strong> ${stage3Result.success ? '‚úÖ Success' : '‚ùå Failed'}</p>
        ${stage3Result.replacements ? `
        <p><strong>Replacements Made:</strong> ${stage3Result.replacements.length || 0}</p>
        ` : ''}
        ${stage3Result.validation ? `
        <p><strong>Syntax Valid:</strong> ${stage3Result.validation.syntax_valid ? '‚úÖ Yes' : '‚ùå No'}</p>
        <p><strong>TODOs Remaining:</strong> ${stage3Result.validation.has_todos ? '‚ùå Yes' : '‚úÖ None'}</p>
        ` : ''}
    </div>
    
    <div class="stage">
        <h2 class="info">üìã Final Code:</h2>
        <div class="code-block">${finalCode ? finalCode.replace(/</g, '&lt;').replace(/>/g, '&gt;') : 'No final code generated'}</div>
    </div>
    
    <div class="stage">
        <h2 class="warning">‚ö†Ô∏è Next Steps:</h2>
        <p>1. Review the four-stage transformation process</p>
        <p>2. Verify the final code meets your requirements</p>
        <p>3. Apply changes to your file if satisfied</p>
        <p>4. Test the enhanced code functionality</p>
    </div>
</body>
</html>`;
                
                // Show in webview
                const panel = vscode.window.createWebviewPanel(
                    'fourStageGeminiResults',
                    'Four-Stage Gemini Results',
                    vscode.ViewColumn.Beside,
                    { enableScripts: true }
                );
                panel.webview.html = resultsHtml;
                
                // Ask if user wants to apply changes
                const applyChanges = await vscode.window.showInformationMessage(
                    `üéâ Four-Stage Gemini Complete!\n` +
                    `üß† Stage 0: ${stage0Result.success ? '‚úÖ' : '‚ùå'} Code Understanding\n` +
                    `üìã Stage 1: ${stage1Result.success ? '‚úÖ' : '‚ùå'} Comprehensive Planning\n` +
                    `üõ†Ô∏è Stage 2: ${stage2Result.success ? '‚úÖ' : '‚ùå'} Implementation\n` +
                    `üîÑ Stage 3: ${stage3Result.success ? '‚úÖ' : '‚ùå'} Intelligent Replacement\n\n` +
                    `Apply changes to file?`,
                    'Apply Changes', 'Review Only'
                );
                
                if (applyChanges === 'Apply Changes') {
                    // Apply the final code to the editor
                    const edit = new vscode.WorkspaceEdit();
                    const fullRange = new vscode.Range(
                        document.positionAt(0),
                        document.positionAt(codeContent.length)
                    );
                    edit.replace(document.uri, fullRange, finalCode);
                    await vscode.workspace.applyEdit(edit);
                    await document.save();
                    
                    vscode.window.showInformationMessage(
                        `üéâ Four-Stage Gemini Applied!\n` +
                        `‚úÖ Code understood, planned, implemented and replaced\n` +
                        `‚úÖ All stages completed successfully\n` +
                        `‚úÖ Code is now complete and functional`
                    );
                }
                
            } else {
                vscode.window.showErrorMessage('Four-Stage Gemini failed: ' + (result.error || 'Unknown error'));
            }
            
        } catch (error) {
            vscode.window.showErrorMessage('Four-Stage Gemini error: ' + error.message);
        }
    });
    
    // Register all commands
    context.subscriptions.push(
        completeCodeCommand,
        autoFixCommand,
        globalCompleteCommand,
        writeFixedCodeCommand,
        analyzeCommand,
        workspaceInfoCommand,
        toggleAutoCompleteCommand,
        twoStageGeminiFixCommand,
        threeStageGeminiFixCommand,
        apiKeyStatusCommand,
        enhancedSyntaxFixCommand,
        fourStageGeminiFixCommand
    );
    
    // Document change listeners
    const onDidSaveDocument = vscode.workspace.onDidSaveTextDocument(async (document) => {
        await analyzeAndShowDiagnostics(document);
    });
    
    const onDidOpenDocument = vscode.workspace.onDidOpenTextDocument(async (document) => {
        await analyzeAndShowDiagnostics(document);
    });
    
    context.subscriptions.push(onDidSaveDocument, onDidOpenDocument);
    
    // Initialize status bar
    updateStatusBar();
    
    // Analyze currently open file
    if (vscode.window.activeTextEditor) {
        analyzeAndShowDiagnostics(vscode.window.activeTextEditor.document);
    }
    
    console.log('SuperAI Extension activated successfully!');
    vscode.window.showInformationMessage('SuperAI Extension activated! üöÄ');
}

function deactivate() {
    if (diagnosticCollection) {
        diagnosticCollection.dispose();
    }
    if (statusBarItem) {
        statusBarItem.dispose();
    }
    console.log('SuperAI Extension deactivated.');
}

module.exports = {
    activate,
    deactivate
};
